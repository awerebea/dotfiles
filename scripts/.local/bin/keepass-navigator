#!/usr/bin/env bash

# keepass-navigator - Interactive KeePassXC database navigator with FZF
# Features:
#   - Browse KeePass database entries with FZF
#   - Copy selected fields to clipboard
#   - Support for TOTP codes
#   - Search and group navigation
#   - Cross-platform secret retrieval
#   - Intelligent FZF configuration with version detection
#   - Proper key handling (Ctrl+Q to go back, Ctrl+C to exit)
#
# Customization:
#   - Set KEEPASS_FZF_OPTS to override default FZF options
#   - FZF version detection ensures compatibility

set -euo pipefail

# Global variables
DATABASE=""
KEYFILE=""
SECRET_NAME=""
NO_PASSWORD=false
YUBIKEY=false
SEARCH_QUERY=""
GROUP_PATH=""
TEMP_FILES=()
CACHED_PASSWORD=""

# Color variables (inspired by fzf-git-branches)
readonly col_reset='\033[0m'
readonly col_r='\033[31m'      # red
readonly col_y='\033[33m'      # yellow
readonly col_g='\033[32m'      # green
readonly col_b='\033[34m'      # blue
readonly col_bold='\033[1m'
readonly col_r_bold='\033[1;31m'  # red bold
readonly col_y_bold='\033[1;33m'  # yellow bold
readonly col_g_bold='\033[1;32m'  # green bold
readonly col_b_bold='\033[1;34m'  # blue bold

# FZF configuration (inspired by fzf-git-branches)
get_fzf_cmd() {
    local fzf_version
    fzf_version="$(fzf --version | awk -F. '{ print $1 * 1e6 + $2 * 1e3 + $3 }')"
    local fzf_min_version=16001

    # Default FZF arguments
    local FZF_ARGS="\
        --ansi \
        --bind=ctrl-c:abort,ctrl-q:abort \
        --cycle \
        --pointer='' \
    "

    # Override with user preferences if set
    FZF_ARGS="${KEEPASS_FZF_OPTS:-"$FZF_ARGS"}"

    # Return FZF command based on version
    if [[ $fzf_version -gt $fzf_min_version ]]; then
        echo "fzf --height 80% --reverse $FZF_ARGS"
    elif [[ ${FZF_TMUX:-1} -eq 1 ]]; then
        echo "fzf-tmux -d${FZF_TMUX_HEIGHT:-40%} $FZF_ARGS"
    else
        echo "fzf $FZF_ARGS"
    fi
}

# Cleanup function
cleanup() {
    # Clear cached password from memory
    if [[ -n "$CACHED_PASSWORD" ]]; then
        unset CACHED_PASSWORD
    fi

    # Clean up temporary files
    for file in "${TEMP_FILES[@]}"; do
        [[ -f "$file" ]] && rm -f "$file"
    done
}
trap cleanup EXIT

usage() {
    cat <<EOF
Usage: $0 [OPTIONS] [search_terms...]
       $0 [OPTIONS] -- group/path

Interactive KeePassXC database navigator with FZF selection.

OPTIONS:
    -d, --database PATH      KeePass database file (.kdbx)
    -k, --key-file PATH      Key file for database encryption
    -s, --secret-name NAME   Retrieve password from keychain secret
    --no-password           Database has no password (mutually exclusive with -s)
    -y, --yubikey           Use YubiKey for authentication (can combine with others)
    -h, --help              Show this help

AUTHENTICATION:
    - Password: Prompted by default (unless --no-password or -s/--secret-name specified)
    - Keyfile: Optional, can be combined with any password method
    - YubiKey: Optional, can be combined with password/keyfile
    - Secret: Alternative to password prompt
    - No-password: For keyfile-only databases (conflicts with -s/--secret-name)

EXAMPLES:
    $0 -d vault.kdbx -s keepass-secret
    $0 -d vault.kdbx -k keyfile.key --no-password aws sso
    $0 -d vault.kdbx --yubikey -- work/Bright MLS
    $0 -d vault.kdbx -k keyfile.key --yubikey  # YubiKey + keyfile + password
    $0 -d vault.kdbx  # Will prompt for password

NAVIGATION:
    - Entry Selection: Ctrl+C/Ctrl+Q to exit
    - Field Selection: Ctrl+Q to go back to entries, Ctrl+C to exit
    - After copying a field: continues field selection loop

FZF CUSTOMIZATION:
    Set KEEPASS_FZF_OPTS environment variable to override default FZF options

EOF
    exit "${1:-0}"
}

error_exit() {
    echo "‚ùå Error: $1" >&2
    exit 1
}

# Cross-platform secret retrieval (simplified from keychain-secret)
fetch_secret() {
    local service="$1"
    local account="${2:-$USER}"

    if command -v security >/dev/null 2>&1 && [[ "$OSTYPE" == "darwin"* ]]; then
        security find-generic-password -a "$account" -s "$service" -w 2>/dev/null
    elif command -v secret-tool >/dev/null 2>&1; then
        secret-tool lookup service "$service" account "$account" 2>/dev/null
    elif command -v pass >/dev/null 2>&1; then
        pass show "$service/$account" 2>/dev/null
    else
        error_exit "No supported secret backend found (security/secret-tool/pass)"
    fi
}

# Cross-platform clipboard helper
copy_to_clipboard() {
    if [[ "$OSTYPE" == "darwin"* ]]; then
        pbcopy
    elif command -v xclip >/dev/null 2>&1; then
        xclip -selection clipboard
    elif command -v xsel >/dev/null 2>&1; then
        xsel --clipboard --input
    else
        error_exit "Clipboard tool not found (install xclip or xsel)"
    fi
}



# Parse command line arguments
parse_args() {
    local parsing_group=false

    while [[ $# -gt 0 ]]; do
        case $1 in
        -h | --help)
            usage 0
            ;;
        -d | --database)
            [[ -n "${2:-}" ]] || error_exit "Database path required"
            DATABASE="$2"
            shift 2
            ;;
        --database=*)
            DATABASE="${1#*=}"
            [[ -n "$DATABASE" ]] || error_exit "Database path required"
            shift
            ;;
        -k | --key-file)
            [[ -n "${2:-}" ]] || error_exit "Keyfile path required"
            KEYFILE="$2"
            shift 2
            ;;
        --key-file=*)
            KEYFILE="${1#*=}"
            [[ -n "$KEYFILE" ]] || error_exit "Keyfile path required"
            shift
            ;;
        -s | --secret-name)
            [[ -n "${2:-}" ]] || error_exit "Secret name required"
            SECRET_NAME="$2"
            shift 2
            ;;
        --secret-name=*)
            SECRET_NAME="${1#*=}"
            [[ -n "$SECRET_NAME" ]] || error_exit "Secret name required"
            shift
            ;;
        --no-password)
            NO_PASSWORD=true
            shift
            ;;
        --yubikey)
            YUBIKEY=true
            shift
            ;;
        --)
            parsing_group=true
            shift
            break
            ;;
        -*)
            error_exit "Unknown option: $1"
            ;;
        *)
            break
            ;;
        esac
    done

    # Handle remaining arguments
    if [[ "$parsing_group" == true ]]; then
        GROUP_PATH="$*"
    else
        SEARCH_QUERY="$*"
    fi
}



# Validate arguments
validate_args() {
    [[ -n "$DATABASE" ]] || error_exit "Database path required (-d/--database)"
    [[ -f "$DATABASE" ]] || error_exit "Database file not found: $DATABASE"

    # Check authentication options
    # --secret-name and --no-password are mutually exclusive (both define password source)
    if [[ -n "$SECRET_NAME" ]] && [[ "$NO_PASSWORD" == true ]]; then
        error_exit "Cannot use both --secret-name and --no-password"
    fi

    # Check if we have at least one authentication method
    local has_auth=false
    [[ -n "$KEYFILE" ]] && has_auth=true
    [[ -n "$SECRET_NAME" ]] && has_auth=true
    [[ "$NO_PASSWORD" == true ]] && has_auth=true
    [[ "$YUBIKEY" == true ]] && has_auth=true

    # If no explicit auth method specified, we need password prompt or error
    if [[ "$has_auth" == false ]]; then
        # Will prompt for password - this is valid
        :
    fi

    [[ -n "$KEYFILE" && ! -f "$KEYFILE" ]] && error_exit "Keyfile not found: $KEYFILE"

    command -v keepassxc-cli >/dev/null 2>&1 || error_exit "keepassxc-cli not found"
    command -v fzf >/dev/null 2>&1 || error_exit "fzf not found"
}

# Initialize password cache once
init_password() {
    if [[ -z "$CACHED_PASSWORD" ]] && [[ -n "$SECRET_NAME" ]]; then
        CACHED_PASSWORD=$(fetch_secret "$SECRET_NAME") || error_exit "Failed to retrieve secret: $SECRET_NAME"
        echo "üîê Retrieved password from secret store" >&2
    elif [[ -z "$CACHED_PASSWORD" ]] && [[ "$NO_PASSWORD" != true ]]; then
        echo -n "Enter database password: " >&2
        read -s CACHED_PASSWORD
        echo >&2  # New line after hidden input
        echo "üîê Password cached for session" >&2
    fi
}



# Execute keepassxc-cli command with error handling
execute_keepass_cmd() {
    local cmd_args="$1"

    # Build command arguments array
    local cmd_array=("keepassxc-cli")

    # Add keyfile if specified
    if [[ -n "$KEYFILE" ]]; then
        cmd_array+=(--key-file "$KEYFILE")
    fi

    # Add no-password flag if specified
    if [[ "$NO_PASSWORD" == true ]]; then
        cmd_array+=(--no-password)
    fi

    # Add yubikey flag if specified
    if [[ "$YUBIKEY" == true ]]; then
        cmd_array+=(--yubikey)
    fi

    # Add the actual command arguments
    eval "cmd_array+=($cmd_args)"

    local output
    local exit_code

    # Debug output disabled for cleaner interface
    # echo "üîß DEBUG: Executing: ${cmd_array[*]}" >&2

    if [[ -n "$CACHED_PASSWORD" ]]; then
        # Use printf pipe to pass password and only capture stdout
        # Redirect stderr to /dev/null to avoid password prompts in output
        if ! output=$(printf '%s\n' "$CACHED_PASSWORD" | "${cmd_array[@]}" 2>/dev/null); then
            exit_code=$?
            case $exit_code in
            1) error_exit "Invalid credentials or database locked" ;;
            2) error_exit "Database file corrupted or invalid format" ;;
            11) error_exit "Invalid command or arguments" ;;
            *) error_exit "KeePassXC command failed with exit code $exit_code" ;;
            esac
        fi
    else
        # No password needed (--no-password case)
        if ! output=$("${cmd_array[@]}" 2>/dev/null); then
            exit_code=$?
            case $exit_code in
            1) error_exit "Invalid credentials or database locked" ;;
            2) error_exit "Database file corrupted or invalid format" ;;
            11) error_exit "Invalid command or arguments" ;;
            *) error_exit "KeePassXC command failed with exit code $exit_code" ;;
            esac
        fi
    fi

    echo "$output"
}

# List database entries
list_entries() {
    local cmd_args

    if [[ -n "$GROUP_PATH" ]]; then
        cmd_args="ls -q -R -f '$DATABASE' '$GROUP_PATH'"
    elif [[ -n "$SEARCH_QUERY" ]]; then
        cmd_args="search -q '$DATABASE' '$SEARCH_QUERY'"
    else
        cmd_args="ls -q -R -f '$DATABASE'"
    fi

    execute_keepass_cmd "$cmd_args"
}

# Get entry details (raw format)
get_entry_details_raw() {
    local entry_path="$1"
    execute_keepass_cmd "show --all '$DATABASE' '$entry_path'"
}

# Format entry details as colored table (inspired by fzf-git-branches)
format_entry_details() {
    local entry_path="$1"

    # Get raw details
    local raw_details
    raw_details=$(get_entry_details_raw "$entry_path")

    # Parse raw details into key-value pairs (no header in selectable data)
    local -a attributes=()
    local -a values=()
    local max_attr_width=0

    # Process each line of raw output
    while IFS= read -r line; do
        # Skip empty lines
        [[ -z "$line" ]] && continue

        # Extract attribute and value (split on first colon)
        if [[ "$line" =~ ^([^:]+):[[:space:]]*(.*) ]]; then
            local attr="${BASH_REMATCH[1]}"
            local val="${BASH_REMATCH[2]}"

            # Skip if no value or if it's just whitespace
            [[ -z "$val" || "$val" =~ ^[[:space:]]*$ ]] && continue

            attributes+=("$attr")
            values+=("$val")

            # Track maximum attribute width
            local attr_width=${#attr}
            [[ $attr_width -gt $max_attr_width ]] && max_attr_width=$attr_width
        fi
    done <<< "$raw_details"

    # Calculate spacer (inspired by fzf-git-branches spacer calculation)
    local terminal_width
    terminal_width=$(tput cols 2>/dev/null || echo "80")
    local total_width=$((max_attr_width + 20))  # Add some padding
    local spacer_width=4
    [[ $total_width -gt $terminal_width ]] && spacer_width=2
    [[ $spacer_width -le 0 ]] && spacer_width=1

    local spacer
    spacer=$(printf "%${spacer_width}s" "")

    # Output formatted table (data rows only, header will be in FZF header)
    local i=0
    for attr in "${attributes[@]}"; do
        local val="${values[$i]}"

        # All rows are data rows with colors: yellow bold for attribute, green for value
        printf "${col_y_bold}%-${max_attr_width}s${col_reset}${spacer}${col_g}%s${col_reset}\n" "$attr" "$val"

        ((i++))
    done
}

# Create FZF header with keybindings and table header (inspired by fzf-git-branches)
create_field_selection_header() {
    local entry_path="$1"

    # Calculate column widths based on entry data for proper alignment
    local raw_details
    raw_details=$(get_entry_details_raw "$entry_path")

    local max_attr_width=0
    while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        if [[ "$line" =~ ^([^:]+):[[:space:]]*(.*) ]]; then
            local attr="${BASH_REMATCH[1]}"
            local val="${BASH_REMATCH[2]}"
            [[ -z "$val" || "$val" =~ ^[[:space:]]*$ ]] && continue
            local attr_width=${#attr}
            [[ $attr_width -gt $max_attr_width ]] && max_attr_width=$attr_width
        fi
    done <<< "$raw_details"

    # Calculate spacer
    local terminal_width
    terminal_width=$(tput cols 2>/dev/null || echo "80")
    local spacer_width=4
    [[ $((max_attr_width + 20)) -gt $terminal_width ]] && spacer_width=2
    [[ $spacer_width -le 0 ]] && spacer_width=1

    local spacer
    spacer=$(printf "%${spacer_width}s" "")

    # Build header with keybindings and table header (no separator line)
    # Note: FZF handles ANSI codes in headers, so we can use colors directly
    local header="Field Selection: Ctrl+Q:back, Ctrl+C:exit, Enter:copy field"
    header+=$'\n'
    # Simple table header without ANSI codes to avoid display issues
    # Use one less space in header to match data row alignment
    local header_spacer
    header_spacer=$(printf "%$((spacer_width - 1))s" "")
    header+="$(printf "%-${max_attr_width}s" "Attribute")${header_spacer}Value"

    echo "$header"
}

# Copy field to clipboard
copy_field_to_clipboard() {
    local entry_path="$1"
    local field_name="$2"

    if [[ "$field_name" == "otp" ]]; then
        # Handle TOTP - use --totp flag to get the current TOTP code
        execute_keepass_cmd "clip --totp '$DATABASE' '$entry_path' 0" >/dev/null
        echo "üîê TOTP code copied to clipboard"
    else
        # Handle regular fields - use --attribute flag
        execute_keepass_cmd "clip --attribute '$field_name' '$DATABASE' '$entry_path' 0" >/dev/null
        echo "üìã '$field_name' copied to clipboard"
    fi
}

# Main entry selection loop
select_entry() {
    while true; do
        echo "üîç KeePass Database: $(basename "$DATABASE")"
        [[ -n "$GROUP_PATH" ]] && echo "üìÅ Group: $GROUP_PATH"
        [[ -n "$SEARCH_QUERY" ]] && echo "üîç Search: $SEARCH_QUERY"
        echo "üìã Select entry (Ctrl+C/Ctrl+Q to exit):"
        echo

        local entries
        entries=$(list_entries)

        [[ -z "$entries" ]] && {
            echo "‚ùå No entries found"
            return 1
        }

        # Use fzf with --expect to capture key presses
        local fzf_cmd
        fzf_cmd=$(get_fzf_cmd)
        local lines
        lines=$(echo "$entries" | eval "$fzf_cmd --expect='ctrl-c,ctrl-q' --prompt='Select entry: '")

        # Check if we got any output
        [[ -z "$lines" ]] && {
            echo "üëã Goodbye!"
            exit 0
        }

        local key
        key=$(head -1 <<< "$lines")
        local selected_entry
        selected_entry=$(tail -1 <<< "$lines")

        case "$key" in
            ctrl-c|ctrl-q)
                echo "üëã Goodbye!"
                exit 0
                ;;
            *)
                # Regular selection or empty key (Enter pressed)
                ;;
        esac

        [[ -n "$selected_entry" ]] && select_field "$selected_entry"
    done
}

# Field selection loop
select_field() {
    local entry_path="$1"

    while true; do
        echo
        echo "üìÑ Entry: '$entry_path'"
        echo

        # Get formatted entry details with colors and proper table alignment
        local entry_details
        entry_details=$(format_entry_details "$entry_path")

        # Create header with keybindings and table headers (inspired by fzf-git-branches)
        local header
        header=$(create_field_selection_header "$entry_path")

        # Use fzf with header containing keybindings and table headers
        local fzf_cmd
        fzf_cmd=$(get_fzf_cmd)
        local lines
        lines=$(echo "$entry_details" | eval "$fzf_cmd --expect='ctrl-c,ctrl-q' --header='$header' --prompt='‚ùØ '")

        # Handle empty output (cancelled)
        [[ -z "$lines" ]] && return 0

        local key
        key=$(head -1 <<< "$lines")
        local selected_line
        selected_line=$(tail -1 <<< "$lines")

        case "$key" in
            ctrl-c)
                echo "üëã Goodbye!"
                exit 0
                ;;
            ctrl-q)
                return 0  # Go back to entry selection
                ;;
            *)
                # Regular selection or empty key (Enter pressed)
                ;;
        esac

        if [[ -n "$selected_line" ]]; then
            # Extract field name from formatted line (remove ANSI colors and get first column)
            local field_name
            field_name=$(echo "$selected_line" | sed 's/\x1b\[[0-9;]*m//g' | awk '{print $1}')

            if [[ -n "$field_name" ]]; then
                copy_field_to_clipboard "$entry_path" "$field_name"
                echo
                echo "üîÑ Select another field or press Ctrl+Q to go back"
            fi
        fi
    done
}

# Main function
main() {
    parse_args "$@"
    validate_args

    # FZF configuration will be set up on-demand via get_fzf_cmd

    # Initialize password once at the main level (before any subshells)
    init_password

    echo "üîê KeePass Navigator"
    echo "==================="

    select_entry
}

# Run main function
main "$@"
