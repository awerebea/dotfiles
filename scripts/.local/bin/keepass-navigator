#!/usr/bin/env bash

# keepass-navigator - Interactive KeePassXC database navigator with FZF
# Features:
#   - Browse KeePass database entries with FZF
#   - Copy selected fields to clipboard
#   - Support for TOTP codes
#   - Search and group navigation
#   - Cross-platform secret retrieval
#   - Intelligent FZF configuration with version detection
#   - Proper key handling (Ctrl+Q to go back, Ctrl+C to exit)
#
# Customization:
#   - Set KEEPASS_FZF_OPTS to override default FZF options
#   - FZF version detection ensures compatibility

set -euo pipefail

# Global variables
DATABASE=""
KEYFILE=""
SECRET_NAME=""
NO_PASSWORD=false
YUBIKEY=false
SEARCH_QUERY=""
GROUP_PATH=""
CACHED_PASSWORD=""
DEBUG=false
SHOW_ALL_ATTRIBUTES=false

# Hidden attributes (shown only when --show-all-attributes is used)
HIDDEN_ATTRIBUTES=(
    "Uuid"
    "PEDCalc.interval"
)

# Color variables (inspired by fzf-git-branches)
readonly col_reset='\033[0m'
# readonly col_r='\033[31m' # red
# readonly col_y='\033[33m' # yellow
readonly col_g='\033[32m' # green
readonly col_b='\033[34m' # blue
# readonly col_bold='\033[1m'
# readonly col_r_bold='\033[1;31m' # red bold
readonly col_y_bold='\033[1;33m' # yellow bold
# readonly col_g_bold='\033[1;32m' # green bold
# readonly col_b_bold='\033[1;34m' # blue bold

# FZF configuration (inspired by fzf-git-branches)
get_fzf_cmd() {
    local fzf_version
    fzf_version="$(fzf --version | awk -F. '{ print $1 * 1e6 + $2 * 1e3 + $3 }')"
    local fzf_min_version=16001

    # Default FZF arguments
    local FZF_ARGS="\
        --ansi \
        --bind=ctrl-c:abort,ctrl-q:abort \
        --cycle \
        --pointer='' \
    "

    # Override with user preferences if set
    FZF_ARGS="${KEEPASS_FZF_OPTS:-"$FZF_ARGS"}"

    # Return FZF command based on version
    if [[ $fzf_version -gt $fzf_min_version ]]; then
        echo "fzf --height 80% --reverse $FZF_ARGS"
    elif [[ ${FZF_TMUX:-1} -eq 1 ]]; then
        echo "fzf-tmux -d${FZF_TMUX_HEIGHT:-40%} $FZF_ARGS"
    else
        echo "fzf $FZF_ARGS"
    fi
}

# Cleanup function
cleanup() {
    # Clear cached password from memory
    if [[ -n "$CACHED_PASSWORD" ]]; then
        unset CACHED_PASSWORD
    fi
}
trap cleanup EXIT

usage() {
    cat <<EOF
Usage: $0 [OPTIONS] [search_terms...]
       $0 [OPTIONS] -- group/path

Interactive KeePassXC database navigator with FZF selection.

OPTIONS:
    -d, --database PATH      KeePass database file (.kdbx)
    -k, --key-file PATH      Key file for database encryption
    -s, --secret-name NAME   Retrieve password from keychain secret
    --no-password           Database has no password (mutually exclusive with -s)
    -y, --yubikey           Use YubiKey for authentication (can combine with others)
    --show-all-attributes   Show all entry attributes (including uuid and other hidden fields)
    --debug                 Show debug output and status messages
    -h, --help              Show this help

AUTHENTICATION:
    - Password: Prompted by default (unless --no-password or -s/--secret-name specified)
    - Keyfile: Optional, can be combined with any password method
    - YubiKey: Optional, can be combined with password/keyfile
    - Secret: Alternative to password prompt
    - No-password: For keyfile-only databases (conflicts with -s/--secret-name)

EXAMPLES:
    $0 -d vault.kdbx -s keepass-secret
    $0 -d vault.kdbx -k keyfile.key --no-password aws sso
    $0 -d vault.kdbx --yubikey -- work/Bright MLS
    $0 -d vault.kdbx -k keyfile.key --yubikey  # YubiKey + keyfile + password
    $0 -d vault.kdbx  # Will prompt for password

NAVIGATION:
    - Entry Selection: Ctrl+C/Ctrl+Q to exit
    - Field Selection: Ctrl+Q to go back to entries, Ctrl+C to exit
    - After copying a field: continues field selection loop

FZF CUSTOMIZATION:
    Set KEEPASS_FZF_OPTS environment variable to override default FZF options

EOF
    exit "${1:-0}"
}

error_exit() {
    echo "‚ùå Error: $1" >&2
    exit 1
}

# Debug output function
debug_echo() {
    if [[ "$DEBUG" == true ]]; then
        echo "$@"
    fi
}

# Cross-platform secret retrieval (simplified from keychain-secret)
fetch_secret() {
    local service="$1"
    local account="${2:-$USER}"

    if command -v security >/dev/null 2>&1 && [[ "$OSTYPE" == "darwin"* ]]; then
        security find-generic-password -a "$account" -s "$service" -w 2>/dev/null
    elif command -v secret-tool >/dev/null 2>&1; then
        secret-tool lookup service "$service" account "$account" 2>/dev/null
    elif command -v pass >/dev/null 2>&1; then
        pass show "$service/$account" 2>/dev/null
    else
        error_exit "No supported secret backend found (security/secret-tool/pass)"
    fi
}

# Cross-platform clipboard helper
copy_to_clipboard() {
    if [[ "$OSTYPE" == "darwin"* ]]; then
        pbcopy
    elif command -v xclip >/dev/null 2>&1; then
        xclip -selection clipboard
    elif command -v xsel >/dev/null 2>&1; then
        xsel --clipboard --input
    else
        error_exit "Clipboard tool not found (install xclip or xsel)"
    fi
}

# Parse command line arguments
parse_args() {
    local parsing_group=false

    while [[ $# -gt 0 ]]; do
        case $1 in
        -h | --help)
            usage 0
            ;;
        -d | --database)
            [[ -n "${2:-}" ]] || error_exit "Database path required"
            DATABASE="$2"
            shift 2
            ;;
        --database=*)
            DATABASE="${1#*=}"
            [[ -n "$DATABASE" ]] || error_exit "Database path required"
            shift
            ;;
        -k | --key-file)
            [[ -n "${2:-}" ]] || error_exit "Keyfile path required"
            KEYFILE="$2"
            shift 2
            ;;
        --key-file=*)
            KEYFILE="${1#*=}"
            [[ -n "$KEYFILE" ]] || error_exit "Keyfile path required"
            shift
            ;;
        -s | --secret-name)
            [[ -n "${2:-}" ]] || error_exit "Secret name required"
            SECRET_NAME="$2"
            shift 2
            ;;
        --secret-name=*)
            SECRET_NAME="${1#*=}"
            [[ -n "$SECRET_NAME" ]] || error_exit "Secret name required"
            shift
            ;;
        --no-password)
            NO_PASSWORD=true
            shift
            ;;
        --yubikey)
            YUBIKEY=true
            shift
            ;;
        --debug)
            DEBUG=true
            shift
            ;;
        --show-all-attributes)
            SHOW_ALL_ATTRIBUTES=true
            shift
            ;;
        --)
            parsing_group=true
            shift
            break
            ;;
        -*)
            error_exit "Unknown option: $1"
            ;;
        *)
            break
            ;;
        esac
    done

    # Handle remaining arguments
    if [[ "$parsing_group" == true ]]; then
        GROUP_PATH="$*"
    else
        SEARCH_QUERY="$*"
    fi
}

# Validate arguments
validate_args() {
    [[ -n "$DATABASE" ]] || error_exit "Database path required (-d/--database)"
    [[ -f "$DATABASE" ]] || error_exit "Database file not found: $DATABASE"

    # Check authentication options
    # --secret-name and --no-password are mutually exclusive (both define password source)
    if [[ -n "$SECRET_NAME" ]] && [[ "$NO_PASSWORD" == true ]]; then
        error_exit "Cannot use both --secret-name and --no-password"
    fi

    # Check if we have at least one authentication method
    local has_auth=false
    [[ -n "$KEYFILE" ]] && has_auth=true
    [[ -n "$SECRET_NAME" ]] && has_auth=true
    [[ "$NO_PASSWORD" == true ]] && has_auth=true
    [[ "$YUBIKEY" == true ]] && has_auth=true

    # If no explicit auth method specified, we need password prompt or error
    if [[ "$has_auth" == false ]]; then
        # Will prompt for password - this is valid
        :
    fi

    [[ -n "$KEYFILE" && ! -f "$KEYFILE" ]] && error_exit "Keyfile not found: $KEYFILE"

    command -v keepassxc-cli >/dev/null 2>&1 || error_exit "keepassxc-cli not found"
    command -v fzf >/dev/null 2>&1 || error_exit "fzf not found"
}

# Initialize password cache once
init_password() {
    if [[ -z "$CACHED_PASSWORD" ]] && [[ -n "$SECRET_NAME" ]]; then
        CACHED_PASSWORD=$(fetch_secret "$SECRET_NAME") || error_exit "Failed to retrieve secret: $SECRET_NAME"
        if [[ "$DEBUG" == true ]]; then echo "üîê Retrieved password from secret store" >&2; fi
    elif [[ -z "$CACHED_PASSWORD" ]] && [[ "$NO_PASSWORD" != true ]]; then
        echo -n "Enter database password: " >&2
        read -rs CACHED_PASSWORD
        echo >&2 # New line after hidden input
        if [[ "$DEBUG" == true ]]; then echo "üîê Password cached for session" >&2; fi
    fi
}

# Execute keepassxc-cli command with error handling
execute_keepass_cmd() {
    local cmd_args="$1"

    # Build command arguments array
    local cmd_array=("keepassxc-cli")

    # Add keyfile if specified
    if [[ -n "$KEYFILE" ]]; then
        cmd_array+=(--key-file "$KEYFILE")
    fi

    # Add no-password flag if specified
    if [[ "$NO_PASSWORD" == true ]]; then
        cmd_array+=(--no-password)
    fi

    # Add yubikey flag if specified
    if [[ "$YUBIKEY" == true ]]; then
        cmd_array+=(--yubikey)
    fi

    # Add the actual command arguments
    eval "cmd_array+=($cmd_args)"

    local output
    local exit_code

    if [[ -n "$CACHED_PASSWORD" ]]; then
        # Use printf pipe to pass password and capture both stdout and stderr
        {
            output=$(printf '%s\n' "$CACHED_PASSWORD" | "${cmd_array[@]}" 2>&1)
            exit_code=$?
        } 2>/dev/null

        if [[ $exit_code -ne 0 ]]; then
            # Output error to stderr and return with exit code
            echo "‚ùå Error: keepassxc-cli failed (exit code $exit_code): $output" >&2
            return "$exit_code"
        fi
    else
        # No password needed (--no-password case)
        output=$("${cmd_array[@]}" 2>&1)
        exit_code=$?

        if [[ $exit_code -ne 0 ]]; then
            # Output error to stderr and return with exit code
            echo "‚ùå Error: keepassxc-cli failed (exit code $exit_code): $output" >&2
            return "$exit_code"
        fi
    fi

    echo "$output"
}

# List database entries
list_entries() {
    local cmd_args

    if [[ -n "$GROUP_PATH" ]]; then
        cmd_args="ls -q -R -f '$DATABASE' '$GROUP_PATH'"
    elif [[ -n "$SEARCH_QUERY" ]]; then
        cmd_args="search -q '$DATABASE' '$SEARCH_QUERY'"
    else
        cmd_args="ls -q -R -f '$DATABASE'"
    fi

    local raw_output
    raw_output=$(execute_keepass_cmd "$cmd_args")
    local cmd_exit_code=$?

    # If execute_keepass_cmd failed, exit immediately
    if [[ $cmd_exit_code -ne 0 ]]; then
        exit "$cmd_exit_code"
    fi

    # Filter out directory paths and empty groups - keep only actual entry lines
    # Remove: empty directories (lines ending with '/[empty]'), and directory paths (lines ending with '/')
    local filtered_output
    filtered_output=$(echo "$raw_output" | grep -v -E '/\[empty\]$|/$')

    # Add colored formatting: group path in blue, entry name in green, separator in white
    echo "$filtered_output" | while IFS= read -r line; do
        if [[ "$line" == */* ]]; then
            # Entry with group path - split at the last '/'
            local group_path="${line%/*}"
            local entry_name="${line##*/}"
            printf "${col_b}%s${col_reset}/${col_g}%s${col_reset}\n" "$group_path" "$entry_name"
        else
            # Entry without group path (root level) - just color in green
            printf "${col_g}%s${col_reset}\n" "$line"
        fi
    done
}

# Get entry details (raw format)
get_entry_details_raw() {
    local entry_path="$1"
    local output
    output=$(execute_keepass_cmd "show --all '$DATABASE' '$entry_path'")
    local cmd_exit_code=$?

    # If execute_keepass_cmd failed, exit immediately
    if [[ $cmd_exit_code -ne 0 ]]; then
        exit "$cmd_exit_code"
    fi

    echo "$output"
}

# Parse entry attributes and return structured data (no nameref complications)
parse_entry_attributes() {
    local entry_path="$1"

    # Get raw details
    local raw_details
    raw_details=$(get_entry_details_raw "$entry_path")

    # Debug: Show raw details retrieval (to stderr to avoid contaminating parsing)
    if [[ "$DEBUG" == true ]]; then
        debug_echo "üîç Getting raw details for: '$entry_path'" >&2
        if [[ -z "$raw_details" ]]; then
            debug_echo "‚ùå No raw details returned!" >&2
            return 1
        else
            debug_echo "‚úÖ Raw details received (${#raw_details} chars)" >&2
            debug_echo "Raw details preview:" >&2
            echo "$raw_details" | head -5 | sed 's/^/    /' >&2
        fi
    fi

    # Initialize local arrays and width
    local -a attributes=()
    local -a values=()
    local max_width=0

    # Process each line of raw output
    while IFS= read -r line; do
        # Skip empty lines
        [[ -z "$line" ]] && continue

        # Extract attribute and value (split on first colon)
        if [[ "$line" =~ ^([^:]+):[[:space:]]*(.*) ]]; then
            local attr="${BASH_REMATCH[1]}"
            local val="${BASH_REMATCH[2]}"

            # Skip if no value or if it's just whitespace
            [[ -z "$val" || "$val" =~ ^[[:space:]]*$ ]] && continue

            # Skip hidden attributes unless --show-all-attributes is used
            if [[ "$SHOW_ALL_ATTRIBUTES" != true ]]; then
                local is_hidden=false
                local hidden_attr
                for hidden_attr in "${HIDDEN_ATTRIBUTES[@]}"; do
                    if [[ "$attr" == "$hidden_attr" ]]; then
                        is_hidden=true
                        break
                    fi
                done
                [[ "$is_hidden" == true ]] && continue
            fi

            attributes+=("$attr")
            values+=("$val")

            # Track maximum attribute width
            local attr_width=${#attr}
            [[ $attr_width -gt $max_width ]] && max_width=$attr_width
        fi
    done <<<"$raw_details"

    # Debug: Show parsing results (to stderr to avoid contaminating output)
    if [[ "$DEBUG" == true ]]; then
        debug_echo "üìä Parsing complete: ${#attributes[@]} attributes, max_width=$max_width" >&2
        if [[ ${#attributes[@]} -eq 0 ]]; then
            debug_echo "‚ö†Ô∏è  No attributes parsed - this might indicate a problem!" >&2
        fi
    fi

    # Output structured data: max_width|attr1|val1|attr2|val2|...
    local output="$max_width"
    local i
    for i in "${!attributes[@]}"; do
        output+="|${attributes[$i]}|${values[$i]}"
    done
    echo "$output"
}

# Format entry details from structured data string
format_entry_details_from_parsed_data() {
    local parsed_data="$1"

    # Parse structured data: max_width|attr1|val1|attr2|val2|...
    IFS='|' read -ra parts <<<"$parsed_data"
    local max_attr_width="${parts[0]}"

    # Extract attributes and values from parts array
    local -a attributes=()
    local -a values=()
    local i
    for ((i = 1; i < ${#parts[@]}; i += 2)); do
        attributes+=("${parts[$i]}")
        values+=("${parts[$((i + 1))]}")
    done

    # Validate inputs
    [[ ${#attributes[@]} -eq 0 ]] && {
        echo "Error: No attributes to format" >&2
        return 1
    }
    [[ ${#attributes[@]} -ne ${#values[@]} ]] && {
        echo "Error: Attributes and values array length mismatch" >&2
        return 1
    }
    [[ $max_attr_width -le 0 ]] && max_attr_width=10

    # Calculate spacer (inspired by fzf-git-branches spacer calculation)
    local terminal_width
    terminal_width=$(tput cols 2>/dev/null || echo "80")
    # Ensure terminal_width is a valid number
    [[ ! "$terminal_width" =~ ^[0-9]+$ ]] && terminal_width=80
    [[ $terminal_width -lt 20 ]] && terminal_width=80

    local total_width=$((max_attr_width + 20)) # Add some padding
    local spacer_width=4
    [[ $total_width -gt $terminal_width ]] && spacer_width=2
    [[ $spacer_width -le 0 ]] && spacer_width=1

    local spacer
    spacer=$(printf "%${spacer_width}s" "")

    # Output formatted table (data rows only, header will be in FZF header)
    for i in "${!attributes[@]}"; do
        local attr="${attributes[$i]}"
        local val="${values[$i]}"

        # All rows are data rows with colors: yellow bold for attribute, green for value
        printf "${col_y_bold}%-${max_attr_width}s${col_reset}${spacer}${col_g}%s${col_reset}\n" "$attr" "$val"
    done
}

# Create FZF header from parsed data string
create_field_selection_header_from_parsed_data() {
    local parsed_data="$1"

    # Extract max_width and find Title attribute from structured data
    IFS='|' read -ra parts <<<"$parsed_data"
    local max_attr_width="${parts[0]}"

    # Find the Title attribute value
    local title_value="Entry" # Default fallback
    local i
    for ((i = 1; i < ${#parts[@]}; i += 2)); do
        if [[ "${parts[$i]}" == "Title" ]]; then
            title_value="${parts[$((i + 1))]}"
            break
        fi
    done

    # Validate input
    [[ $max_attr_width -le 0 ]] && max_attr_width=10

    # Calculate spacer
    local terminal_width
    terminal_width=$(tput cols 2>/dev/null || echo "80")
    # Ensure terminal_width is a valid number
    [[ ! "$terminal_width" =~ ^[0-9]+$ ]] && terminal_width=80
    [[ $terminal_width -lt 20 ]] && terminal_width=80

    local spacer_width=4
    [[ $((max_attr_width + 20)) -gt $terminal_width ]] && spacer_width=2
    [[ $spacer_width -le 0 ]] && spacer_width=1

    local spacer
    spacer=$(printf "%${spacer_width}s" "")

    # Build header with keybindings and table header (no separator line)
    # Note: FZF handles ANSI codes in headers, so we can use colors directly
    local header="$title_value: Ctrl+Q:back, Ctrl+C:exit, Enter:copy field"
    header+=$'\n'
    # Simple table header without ANSI codes to avoid display issues
    # Use one less space in header to match data row alignment
    local header_spacer
    header_spacer=$(printf "%$((spacer_width - 1))s" "")
    header+="$(printf "%-${max_attr_width}s" "Attribute")${header_spacer}Value"

    echo "$header"
}

# Copy field to clipboard
copy_field_to_clipboard() {
    local entry_path="$1"
    local field_name="$2"

    if [[ "$field_name" == "otp" ]]; then
        # Handle TOTP - use --totp flag to get the current TOTP code
        execute_keepass_cmd "clip --totp '$DATABASE' '$entry_path' 0" >/dev/null
        debug_echo "üîê TOTP code copied to clipboard"
    else
        # Handle regular fields - use --attribute flag
        execute_keepass_cmd "clip --attribute '$field_name' '$DATABASE' '$entry_path' 0" >/dev/null
        debug_echo "üìã '$field_name' copied to clipboard"
    fi
}

# Main entry selection loop
select_entry() {
    while true; do
        debug_echo "üîç KeePass Database: $(basename "$DATABASE")"
        [[ -n "$GROUP_PATH" ]] && debug_echo "üìÅ Group: $GROUP_PATH"
        [[ -n "$SEARCH_QUERY" ]] && debug_echo "üîç Search: $SEARCH_QUERY"
        debug_echo "üìã Select entry (Ctrl+C/Ctrl+Q to exit):"
        if [[ "$DEBUG" == true ]]; then echo; fi

        local entries
        entries=$(list_entries)

        if [[ -z "$entries" ]]; then
            echo "‚ùå No entries found" >&2
            return 1
        fi

        # Create header with keybindings for entry selection
        local header="KeePass Database Navigator: Ctrl+C/Ctrl+Q:exit, Enter:select entry"

        # Use fzf with --expect to capture key presses and header
        local fzf_cmd
        fzf_cmd=$(get_fzf_cmd)
        local lines
        lines=$(echo "$entries" | eval "$fzf_cmd --expect='ctrl-c,ctrl-q' --header='$header' --prompt='Select Entry ‚ùØ '")

        # Check if we got any output
        [[ -z "$lines" ]] && {
            debug_echo "üëã Goodbye!"
            exit 0
        }

        local key
        key=$(head -1 <<<"$lines")
        local selected_entry
        selected_entry=$(tail -1 <<<"$lines")

        case "$key" in
        ctrl-c | ctrl-q)
            debug_echo "üëã Goodbye!"
            exit 0
            ;;
        *)
            # Regular selection or empty key (Enter pressed)
            ;;
        esac

        if [[ -n "$selected_entry" ]]; then
            # Construct full path if GROUP_PATH is specified
            local full_entry_path="$selected_entry"
            if [[ -n "$GROUP_PATH" ]]; then
                # Combine GROUP_PATH with selected entry to get full path
                full_entry_path="$GROUP_PATH/$selected_entry"
            fi
            select_field "$full_entry_path"
        fi
    done
}

# Field selection loop
select_field() {
    local entry_path="$1"

    # üöÄ OPTIMIZATION: Parse entry attributes ONCE outside the loop and cache the result
    debug_echo "ÔøΩ Parsing entry data (once): '$entry_path'"
    local parsed_data
    parsed_data=$(parse_entry_attributes "$entry_path")

    # Extract max_width and arrays from parsed data for debug display (once)
    if [[ "$DEBUG" == true ]]; then
        IFS='|' read -ra parts <<<"$parsed_data"
        local max_attr_width="${parts[0]}"
        local -a attributes=()
        local -a values=()
        local i
        for ((i = 1; i < ${#parts[@]}; i += 2)); do
            attributes+=("${parts[$i]}")
            values+=("${parts[$((i + 1))]}")
        done
        debug_echo "üîç Parsed ${#attributes[@]} attributes, max_width=$max_attr_width"
        for i in "${!attributes[@]}"; do
            debug_echo "  [$i] '${attributes[$i]}' = '${values[$i]}'"
        done
        echo
    fi

    while true; do
        if [[ "$DEBUG" == true ]]; then echo; fi
        debug_echo "üìÑ Entry: '$entry_path'"
        if [[ "$DEBUG" == true ]]; then echo; fi

        # üöÄ REUSE cached parsed_data instead of re-parsing

        # Get formatted entry details using parsed data
        local entry_details
        entry_details=$(format_entry_details_from_parsed_data "$parsed_data")

        # Create header using parsed data
        local header
        header=$(create_field_selection_header_from_parsed_data "$parsed_data")

        # Use fzf with header containing keybindings and table headers
        local fzf_cmd
        fzf_cmd=$(get_fzf_cmd)
        local lines
        lines=$(echo "$entry_details" | eval "$fzf_cmd --expect='ctrl-c,ctrl-q' --header='$header' --prompt='Select Attribute ‚ùØ '")

        # Handle empty output (cancelled)
        [[ -z "$lines" ]] && return 0

        local key
        key=$(head -1 <<<"$lines")
        local selected_line
        selected_line=$(tail -1 <<<"$lines")

        case "$key" in
        ctrl-c)
            debug_echo "üëã Goodbye!"
            exit 0
            ;;
        ctrl-q)
            return 0 # Go back to entry selection
            ;;
        *)
            # Regular selection or empty key (Enter pressed)
            ;;
        esac

        if [[ -n "$selected_line" ]]; then
            # Extract field name from formatted line (remove ANSI colors and get first column)
            local field_name
            field_name=$(echo "$selected_line" | sed 's/\x1b\[[0-9;]*m//g' | awk '{print $1}')

            if [[ -n "$field_name" ]]; then
                copy_field_to_clipboard "$entry_path" "$field_name"
                if [[ "$DEBUG" == true ]]; then echo; fi
                debug_echo "üîÑ Select another field or press Ctrl+Q to go back"
            fi
        fi
    done
}

# Main function
main() {
    parse_args "$@"
    validate_args

    # FZF configuration will be set up on-demand via get_fzf_cmd

    # Initialize password once at the main level (before any subshells)
    init_password

    debug_echo "üîê KeePass Navigator"
    debug_echo "==================="

    select_entry
}

# Run main function
main "$@"
