#!/usr/bin/env bash
set -uo pipefail

# Usage function
usage() {
    local script_name
    script_name=$(basename "$0")

    cat >&2 <<EOF
Usage: $script_name <mode> [options] -c <command> [args...]

Modes:
  s, success   Continue executing the command until the first success
  f, fail      Continue executing the command until the first failure

Options:
  -t, --timeout SECONDS           Total timeout in seconds (positive float)
                                  [default: no timeout]
  -p, --pause SECONDS             Pause between iterations (non-negative float)
                                  [default: 5 seconds]
  -i, --pause-increment SECONDS   Increment to pause on each iteration (float, can be negative)
                                  [default: 0]
  -m, --pause-multiplier FLOAT    Multiply pause on each iteration (positive float)
                                  [default: 1]
  -M, --pause-max SECONDS         Maximum pause value (positive float)
                                  [default: no limit]
  -c, --command COMMAND           Command to execute (required)
EOF
    exit 1
}

# Defaults
timeout=""
pause=5
pause_increment=0
pause_multiplier=1
pause_max=""
cmd=()

# Validate first positional argument
if [[ $# -lt 2 ]]; then
    usage
fi

mode=$1
shift

case "$mode" in
s | success) mode="success" ;;
f | fail) mode="fail" ;;
*)
    echo "Error: first argument must be 'success' or 'fail'" >&2
    usage
    ;;
esac

# Argument parsing
while [[ $# -gt 0 ]]; do
    case "$1" in
    -t | --timeout)
        shift
        timeout="$1"
        ;;
    --timeout=*) timeout="${1#*=}" ;;
    -p | --pause)
        shift
        pause="$1"
        ;;
    --pause=*) pause="${1#*=}" ;;
    -i | --pause-increment)
        shift
        pause_increment="$1"
        ;;
    --pause-increment=*) pause_increment="${1#*=}" ;;
    -m | --pause-multiplier)
        shift
        pause_multiplier="$1"
        ;;
    --pause-multiplier=*) pause_multiplier="${1#*=}" ;;
    -M | --pause-max)
        shift
        pause_max="$1"
        ;;
    --pause-max=*) pause_max="${1#*=}" ;;
    -c | --command)
        shift
        cmd=("$@")
        break
        ;;
    *)
        echo "Unknown argument: $1" >&2
        usage
        ;;
    esac
    shift
done

if [[ ${#cmd[@]} -eq 0 ]]; then
    echo "Error: command must be specified with -c or --command" >&2
    usage
fi

# Validation functions
validate_float() {
    local val=$1 name=$2
    printf "%f" "$val" >/dev/null 2>&1 || {
        echo "Error: $name must be a number" >&2
        exit 1
    }
}

validate_positive() {
    local val=$1 name=$2
    validate_float "$val" "$name"
    awk "BEGIN {if($val <= 0) exit 1}" || {
        echo "Error: $name must be positive" >&2
        exit 1
    }
}

validate_non_negative() {
    local val=$1 name=$2
    validate_float "$val" "$name"
    awk "BEGIN {if($val < 0) exit 1}" || {
        echo "Error: $name must be non-negative" >&2
        exit 1
    }
}

# Validate inputs
[[ -n "$timeout" ]] && validate_positive "$timeout" "timeout"
[[ -n "$pause" ]] && validate_non_negative "$pause" "pause"
validate_float "$pause_increment" "pause-increment"
validate_positive "$pause_multiplier" "pause-multiplier"
[[ -n "$pause_max" ]] && validate_non_negative "$pause_max" "pause-max"

# Clamp initial pause to pause-max if needed
if [[ -n "$pause_max" && $(awk "BEGIN {print ($pause > $pause_max)}") -eq 1 ]]; then
    pause="$pause_max"
fi

# Timing
start_time=$(date +%s.%N)
current_pause="$pause"

while :; do
    echo "Executing command: ${cmd[*]}"
    "${cmd[@]}"
    status=$?

    # Exit condition
    if [[ "$mode" == "success" && $status -eq 0 ]] || [[ "$mode" == "fail" && $status -ne 0 ]]; then
        break
    fi

    # Timeout check
    if [[ -n "$timeout" ]]; then
        now=$(date +%s.%N)
        elapsed=$(awk "BEGIN {print $now - $start_time}")
        remaining=$(awk "BEGIN {print $timeout - $elapsed}")
        if (($(awk "BEGIN {print ($remaining <= 0)}"))); then
            echo "Timeout reached ($timeout s)" >&2
            exit 1
        fi
    fi

    # Pause before next iteration (timeout-aware)
    if [[ -n "$current_pause" && $(awk "BEGIN {print ($current_pause>0)}") -eq 1 ]]; then
        if [[ -n "$timeout" && $(awk "BEGIN {print ($current_pause >= $remaining)}") -eq 1 ]]; then
            echo "Next pause ($current_pause s) would exceed timeout. Exiting loop." >&2
            break
        fi
        sleep "$current_pause"
    fi

    # Update pause: multiply then increment
    if [[ -n "$current_pause" ]]; then
        current_pause=$(awk "BEGIN {v=$current_pause * $pause_multiplier + $pause_increment; if(v<0) v=0; print v}")
        # Clamp to pause-max
        if [[ -n "$pause_max" && $(awk "BEGIN {print ($current_pause > $pause_max)}") -eq 1 ]]; then
            current_pause="$pause_max"
        fi
    fi
done

exit "$status"
